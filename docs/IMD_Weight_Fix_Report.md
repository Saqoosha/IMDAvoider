# IMD直接ヒットペナルティ修正レポート

## 概要

本レポートは、IMDAvoider周波数最適化アルゴリズムの重大な修正について記録します。アルゴリズムは直接IMDヒットを適切にペナルティ化できなかったため、実世界で深刻な干渉を引き起こす周波数組み合わせに高得点を与えていました。

## 問題の本質

### 1. 直接IMDヒットが実質的に無視されていた

IMD生成物がチャンネル周波数に正確に重なる場合（0 MHz分離）、深刻な干渉を引き起こします。しかし、元のアルゴリズムはこの重大な状況をほとんどペナルティ化していませんでした：

```python
# 元のペナルティ計算
# 3次IMD直接ヒットの場合:
penalty = (25 - 0)² × 0.03 = 18.75  # 全体約1500点中わずか18.75点！
```

この小さなペナルティは、複数の直接IMDヒットを持つ組み合わせでも98/100の高得点を可能にしていました。

### 2. 重み値は既に誤っていた（しかしこれは主要な問題ではなかった）

元のコードは誤った重み値を使用していました：

```python
# 元の重み（誤って高い）
WEIGHT_3RD_ORDER_2FREQ = 0.1   # -20dBなら0.01であるべき
WEIGHT_3RD_ORDER_3FREQ = 0.03  # -30dBなら0.001であるべき
```

しかし、これらの膨張した重みは実際には助けになっていました（ペナルティを大きくしていた）。それでもアルゴリズムは悪い組み合わせに高得点を与えていました。これは重みエラーが核心的な問題ではなかったことを証明しています。

### 3. 実世界の例が問題を暴露

報告された干渉事例がアルゴリズムの失敗を実証しました：
- **周波数**: R2(5695), A8(5725), B4(5790), F5(5820)
- **アルゴリズム評価**: 98/100 (優秀!)
- **現実**: 全チャンネルで深刻な干渉
- **分析**: すべてのチャンネルに3次IMDが正確に着地：
  - R2(5695) ← 5725 + 5790 - 5820
  - A8(5725) ← 5695 - 5790 + 5820
  - B4(5790) ← 5695 - 5725 + 5820
  - F5(5820) ← -5695 + 5725 + 5790

## 周波数分析表

### 修正前: R2, A8, B4, F5 - 評価98点（誤って高評価）

| IMDタイプ | 計算式 | 結果 | 直接ヒット |
|----------|---------|--------|--------------|
| 3次 | 5695 + 5820 - 5725 | 5790 | **B4にヒット** |
| 3次 | 5695 + 5820 - 5790 | 5725 | **A8にヒット** |
| 3次 | 5725 + 5790 - 5695 | 5820 | **F5にヒット** |
| 3次 | 5725 + 5790 - 5820 | 5695 | **R2にヒット** |

**合計: 8回の直接ヒット** （各チャンネルが3次IMDで2回ずつヒット）

### 修正後: E2, A8, B4, F5 - 評価96点（正しく高評価）

| IMDタイプ | 計算式 | 結果 | 最近接チャンネル | 分離距離 |
|----------|---------|--------|-----------------|------------|
| 3次 | 5685 + 5820 - 5790 | 5715 | A8(5725) | 10 MHz |
| 3次 | 5725 + 5790 - 5820 | 5695 | E2(5685) | 10 MHz |
| 3次 | 5685 + 5820 - 5725 | 5780 | B4(5790) | 10 MHz |
| 2次 | 2×5725 - 5790 | 5660 | E2(5685) | 25 MHz |

**合計: 0回の直接ヒット**

## 解決策

### 1. 直接ヒットへの重大ペナルティ（重要な修正）

```python
def calculate_weighted_interference(imd_freq, frequencies, weight, threshold):
    # ... 既存のコード ...
    
    # 直接ヒットまたは非常に近いIMD生成物への特別ペナルティ
    if difference <= 5:  # 5 MHz以内は直接ヒットとみなす
        # 重大ペナルティ: 通常の100倍として扱う
        base_penalty = (threshold - difference) ** 2 * weight
        return base_penalty * 100
```

この100倍乗数により、直接IMDヒットが重大な事象として適切に認識されるようになりました。

### 2. 重み値の修正（二次的な修正）

実際のdB値に合わせて重み計算も修正しました：

```python
# 修正された実装
def db_to_linear(db):
    """dB値をリニアスケールに変換"""
    return 10 ** (db / 10)

WEIGHT_2ND_ORDER = db_to_linear(0)      # 1.0
WEIGHT_3RD_ORDER_2FREQ = db_to_linear(-20)  # 0.01
WEIGHT_3RD_ORDER_3FREQ = db_to_linear(-30)  # 0.001
```

注：これは実際には生のペナルティを小さくしますが、100倍の直接ヒット乗数と組み合わせることで、正味の効果は正しくなります。

## なぜ直接ヒットには特別な扱いが必要か

1. **受信機飽和**: IMD生成物がチャンネル周波数に正確に着地すると、受信機はそれを希望信号と区別できません
2. **フィルタ保護なし**: チャンネルフィルタはチャンネル周波数を通過させるよう設計されているため、その正確な周波数でのIMDに対してゼロ保護です
3. **累積効果**: 同じ周波数での複数のIMD生成物が加算されます
4. **実世界での検証**: 100倍乗数により、アルゴリズムが実際のパイロットの経験と一致します

## 結論

重要な修正は、直接IMDヒットには重大なペナルティが必要であることを認識することでした。直接ヒット（≤5 MHz分離）への100倍乗数により、アルゴリズムは危険に誤った推奨を与えるものから信頼できる周波数組み合わせを提供するものに変わりました。

重み係数の修正は物理的に正しい値を使用することを保証する二次的な改善でしたが、直接ヒットペナルティこそが実世界の干渉問題を実際に解決したものです。